// Code generated by protoc-gen-go.
// source: flow-record.proto
// DO NOT EDIT!

/*
Package nofutz_FlowMinder is a generated protocol buffer package.

It is generated from these files:
	flow-record.proto

It has these top-level messages:
	CaptureSpec
	IPAddressWrapper
	PacketData
	IPFlow
	FlowRecord
	BgpRecord
	DNSRecord
	CaptureRecordUnion
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// Capture specification
//
type CaptureSpec_Type int32

const (
	CaptureSpec_FLOW     CaptureSpec_Type = 1
	CaptureSpec_BGP_MRT  CaptureSpec_Type = 2
	CaptureSpec_BGP_LIVE CaptureSpec_Type = 4
)

var CaptureSpec_Type_name = map[int32]string{
	1: "FLOW",
	2: "BGP_MRT",
	4: "BGP_LIVE",
}
var CaptureSpec_Type_value = map[string]int32{
	"FLOW":     1,
	"BGP_MRT":  2,
	"BGP_LIVE": 4,
}

func (x CaptureSpec_Type) Enum() *CaptureSpec_Type {
	p := new(CaptureSpec_Type)
	*p = x
	return p
}
func (x CaptureSpec_Type) String() string {
	return proto.EnumName(CaptureSpec_Type_name, int32(x))
}
func (x *CaptureSpec_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CaptureSpec_Type_value, data, "CaptureSpec_Type")
	if err != nil {
		return err
	}
	*x = CaptureSpec_Type(value)
	return nil
}
func (CaptureSpec_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type FlowRecord_L2Proto int32

const (
	FlowRecord_L2_NONE     FlowRecord_L2Proto = 0
	FlowRecord_L2_ETHERNET FlowRecord_L2Proto = 1
)

var FlowRecord_L2Proto_name = map[int32]string{
	0: "L2_NONE",
	1: "L2_ETHERNET",
}
var FlowRecord_L2Proto_value = map[string]int32{
	"L2_NONE":     0,
	"L2_ETHERNET": 1,
}

func (x FlowRecord_L2Proto) Enum() *FlowRecord_L2Proto {
	p := new(FlowRecord_L2Proto)
	*p = x
	return p
}
func (x FlowRecord_L2Proto) String() string {
	return proto.EnumName(FlowRecord_L2Proto_name, int32(x))
}
func (x *FlowRecord_L2Proto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FlowRecord_L2Proto_value, data, "FlowRecord_L2Proto")
	if err != nil {
		return err
	}
	*x = FlowRecord_L2Proto(value)
	return nil
}
func (FlowRecord_L2Proto) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type CaptureRecordUnion_RecordType int32

const (
	CaptureRecordUnion_CAPTURE_SPEC CaptureRecordUnion_RecordType = 1
	CaptureRecordUnion_FLOW_RECORD  CaptureRecordUnion_RecordType = 2
	CaptureRecordUnion_BGP_RECORD   CaptureRecordUnion_RecordType = 3
	CaptureRecordUnion_DNS_RECORD   CaptureRecordUnion_RecordType = 4
)

var CaptureRecordUnion_RecordType_name = map[int32]string{
	1: "CAPTURE_SPEC",
	2: "FLOW_RECORD",
	3: "BGP_RECORD",
	4: "DNS_RECORD",
}
var CaptureRecordUnion_RecordType_value = map[string]int32{
	"CAPTURE_SPEC": 1,
	"FLOW_RECORD":  2,
	"BGP_RECORD":   3,
	"DNS_RECORD":   4,
}

func (x CaptureRecordUnion_RecordType) Enum() *CaptureRecordUnion_RecordType {
	p := new(CaptureRecordUnion_RecordType)
	*p = x
	return p
}
func (x CaptureRecordUnion_RecordType) String() string {
	return proto.EnumName(CaptureRecordUnion_RecordType_name, int32(x))
}
func (x *CaptureRecordUnion_RecordType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CaptureRecordUnion_RecordType_value, data, "CaptureRecordUnion_RecordType")
	if err != nil {
		return err
	}
	*x = CaptureRecordUnion_RecordType(value)
	return nil
}
func (CaptureRecordUnion_RecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{7, 0}
}

// We try to keep as much state about the file that we convert as we
// can, so we have some idea of where this data came from and who
// handled it
type CaptureSpec struct {
	// each flow needs a proper id. Such an id is local to the file
	// in which records refer to it. The capture_spec_id is *not* global.
	// Global significance is actually the remainder of the fields.
	CaptureSpecId *int32 `protobuf:"varint,1,req,name=capture_spec_id,json=captureSpecId" json:"capture_spec_id,omitempty"`
	// Some applications, e.g., BGP may be logging verbose debugging
	// ID's instead of doing a lookup on the capture_spec id above.
	// the caputre spec and debug_id should have a 1-1 mapping between
	// them, but the verbose debug id is self-contained.
	VerboseDebugId    []byte            `protobuf:"bytes,12,opt,name=verbose_debug_id,json=verboseDebugId" json:"verbose_debug_id,omitempty"`
	Type              *CaptureSpec_Type `protobuf:"varint,14,opt,name=type,enum=nofutz.FlowMinder.CaptureSpec_Type,def=1" json:"type,omitempty"`
	TcpdumpExpression *string           `protobuf:"bytes,2,opt,name=tcpdump_expression,json=tcpdumpExpression" json:"tcpdump_expression,omitempty"`
	// What is the location of the capture in string format
	// AT&T West LAX POP 1123231
	CaptureLocation *string `protobuf:"bytes,3,opt,name=capture_location,json=captureLocation" json:"capture_location,omitempty"`
	// What is the location in terms of IP
	CaptureLocationIp *IPAddressWrapper `protobuf:"bytes,4,opt,name=capture_location_ip,json=captureLocationIp" json:"capture_location_ip,omitempty"`
	// if the capture node has a dns name, this is it
	// FQDN e.g., intercept.ny.nofutz.com
	CaptureLocationDns *string `protobuf:"bytes,5,opt,name=capture_location_dns,json=captureLocationDns" json:"capture_location_dns,omitempty"`
	// if there are multiple capture devices in a location
	// which device is this spec.
	// e.g., capturehost01.intercept.ny.nofutz.com
	CaptureNodeSpec *string `protobuf:"bytes,6,opt,name=capture_node_spec,json=captureNodeSpec" json:"capture_node_spec,omitempty"`
	// The interface on which the data was sniffed
	// ETH10
	CaptureNodeInterface []string `protobuf:"bytes,7,rep,name=capture_node_interface,json=captureNodeInterface" json:"capture_node_interface,omitempty"`
	// For BGP we may only be capturing a link between this
	// capture location IP and the ptp_peer.
	PtpPeer *IPAddressWrapper `protobuf:"bytes,13,opt,name=ptp_peer,json=ptpPeer" json:"ptp_peer,omitempty"`
	// Capture retrieval specification. The capture was originally
	// stored somewhere in some file. The original file is identified
	// below. This is important for provenance, e.g., we might have
	// to filter out data that was stored on a compromised host.
	// And if we ever have a bug, this should allow us to reconstruct our
	// state from the source data.
	StorageHost []string `protobuf:"bytes,8,rep,name=storage_host,json=storageHost" json:"storage_host,omitempty"`
	PathToFiles []string `protobuf:"bytes,9,rep,name=path_to_files,json=pathToFiles" json:"path_to_files,omitempty"`
	// A pattern that allows us to identify the sequence of files. The
	// expression is expected to be a PCRE expression.
	//    http://www.pcre.org/current/doc/html/
	//
	// For example, "capture_(%d+)" says that the files are named
	// capture with the sequence number appended after the _
	FilePattern []string `protobuf:"bytes,10,rep,name=file_pattern,json=filePattern" json:"file_pattern,omitempty"`
	// Username of the file owner
	Username         *string `protobuf:"bytes,11,opt,name=username" json:"username,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CaptureSpec) Reset()                    { *m = CaptureSpec{} }
func (m *CaptureSpec) String() string            { return proto.CompactTextString(m) }
func (*CaptureSpec) ProtoMessage()               {}
func (*CaptureSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

const Default_CaptureSpec_Type CaptureSpec_Type = CaptureSpec_FLOW

func (m *CaptureSpec) GetCaptureSpecId() int32 {
	if m != nil && m.CaptureSpecId != nil {
		return *m.CaptureSpecId
	}
	return 0
}

func (m *CaptureSpec) GetVerboseDebugId() []byte {
	if m != nil {
		return m.VerboseDebugId
	}
	return nil
}

func (m *CaptureSpec) GetType() CaptureSpec_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_CaptureSpec_Type
}

func (m *CaptureSpec) GetTcpdumpExpression() string {
	if m != nil && m.TcpdumpExpression != nil {
		return *m.TcpdumpExpression
	}
	return ""
}

func (m *CaptureSpec) GetCaptureLocation() string {
	if m != nil && m.CaptureLocation != nil {
		return *m.CaptureLocation
	}
	return ""
}

func (m *CaptureSpec) GetCaptureLocationIp() *IPAddressWrapper {
	if m != nil {
		return m.CaptureLocationIp
	}
	return nil
}

func (m *CaptureSpec) GetCaptureLocationDns() string {
	if m != nil && m.CaptureLocationDns != nil {
		return *m.CaptureLocationDns
	}
	return ""
}

func (m *CaptureSpec) GetCaptureNodeSpec() string {
	if m != nil && m.CaptureNodeSpec != nil {
		return *m.CaptureNodeSpec
	}
	return ""
}

func (m *CaptureSpec) GetCaptureNodeInterface() []string {
	if m != nil {
		return m.CaptureNodeInterface
	}
	return nil
}

func (m *CaptureSpec) GetPtpPeer() *IPAddressWrapper {
	if m != nil {
		return m.PtpPeer
	}
	return nil
}

func (m *CaptureSpec) GetStorageHost() []string {
	if m != nil {
		return m.StorageHost
	}
	return nil
}

func (m *CaptureSpec) GetPathToFiles() []string {
	if m != nil {
		return m.PathToFiles
	}
	return nil
}

func (m *CaptureSpec) GetFilePattern() []string {
	if m != nil {
		return m.FilePattern
	}
	return nil
}

func (m *CaptureSpec) GetUsername() string {
	if m != nil && m.Username != nil {
		return *m.Username
	}
	return ""
}

type IPAddressWrapper struct {
	// must be at least one or the other
	Ipv4             []byte `protobuf:"bytes,1,opt,name=ipv4" json:"ipv4,omitempty"`
	Ipv6             []byte `protobuf:"bytes,2,opt,name=ipv6" json:"ipv6,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *IPAddressWrapper) Reset()                    { *m = IPAddressWrapper{} }
func (m *IPAddressWrapper) String() string            { return proto.CompactTextString(m) }
func (*IPAddressWrapper) ProtoMessage()               {}
func (*IPAddressWrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *IPAddressWrapper) GetIpv4() []byte {
	if m != nil {
		return m.Ipv4
	}
	return nil
}

func (m *IPAddressWrapper) GetIpv6() []byte {
	if m != nil {
		return m.Ipv6
	}
	return nil
}

// We don't always capture packet data. If we do, this is
// the format
type PacketData struct {
	NanosSinceFlowStart *uint64 `protobuf:"varint,1,opt,name=nanos_since_flow_start,json=nanosSinceFlowStart" json:"nanos_since_flow_start,omitempty"`
	PacketSize          *uint32 `protobuf:"varint,2,opt,name=packet_size,json=packetSize" json:"packet_size,omitempty"`
	// IP per packet see RFC 791
	IpId *uint32 `protobuf:"varint,3,opt,name=ip_id,json=ipId" json:"ip_id,omitempty"`
	// either more fragments after this or offset != 0
	IsFragment *bool `protobuf:"varint,4,opt,name=is_fragment,json=isFragment" json:"is_fragment,omitempty"`
	// TCP related follows RFC 793
	// This is the window advertisement
	// in bytes.
	WindowSize *int32  `protobuf:"varint,5,opt,name=window_size,json=windowSize" json:"window_size,omitempty"`
	Sequence   *uint32 `protobuf:"varint,6,opt,name=sequence" json:"sequence,omitempty"`
	Ack        *uint32 `protobuf:"varint,7,opt,name=ack" json:"ack,omitempty"`
	Syn        *bool   `protobuf:"varint,8,opt,name=syn" json:"syn,omitempty"`
	Fin        *bool   `protobuf:"varint,9,opt,name=fin" json:"fin,omitempty"`
	Reset_     *bool   `protobuf:"varint,10,opt,name=reset" json:"reset,omitempty"`
	// Do we need more understanding of options ip and otherwise
	OptionsL3        *bool  `protobuf:"varint,11,opt,name=options_l3,json=optionsL3" json:"options_l3,omitempty"`
	OptionsL4        *bool  `protobuf:"varint,12,opt,name=options_l4,json=optionsL4" json:"options_l4,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *PacketData) Reset()                    { *m = PacketData{} }
func (m *PacketData) String() string            { return proto.CompactTextString(m) }
func (*PacketData) ProtoMessage()               {}
func (*PacketData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PacketData) GetNanosSinceFlowStart() uint64 {
	if m != nil && m.NanosSinceFlowStart != nil {
		return *m.NanosSinceFlowStart
	}
	return 0
}

func (m *PacketData) GetPacketSize() uint32 {
	if m != nil && m.PacketSize != nil {
		return *m.PacketSize
	}
	return 0
}

func (m *PacketData) GetIpId() uint32 {
	if m != nil && m.IpId != nil {
		return *m.IpId
	}
	return 0
}

func (m *PacketData) GetIsFragment() bool {
	if m != nil && m.IsFragment != nil {
		return *m.IsFragment
	}
	return false
}

func (m *PacketData) GetWindowSize() int32 {
	if m != nil && m.WindowSize != nil {
		return *m.WindowSize
	}
	return 0
}

func (m *PacketData) GetSequence() uint32 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *PacketData) GetAck() uint32 {
	if m != nil && m.Ack != nil {
		return *m.Ack
	}
	return 0
}

func (m *PacketData) GetSyn() bool {
	if m != nil && m.Syn != nil {
		return *m.Syn
	}
	return false
}

func (m *PacketData) GetFin() bool {
	if m != nil && m.Fin != nil {
		return *m.Fin
	}
	return false
}

func (m *PacketData) GetReset_() bool {
	if m != nil && m.Reset_ != nil {
		return *m.Reset_
	}
	return false
}

func (m *PacketData) GetOptionsL3() bool {
	if m != nil && m.OptionsL3 != nil {
		return *m.OptionsL3
	}
	return false
}

func (m *PacketData) GetOptionsL4() bool {
	if m != nil && m.OptionsL4 != nil {
		return *m.OptionsL4
	}
	return false
}

// Flow originates at address
type IPFlow struct {
	// really required
	Address *IPAddressWrapper `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// we may aggregate flows for an entire subnet if we
	// get too fine-grained with individual flow records.
	Mask  *IPAddressWrapper `protobuf:"bytes,2,opt,name=mask" json:"mask,omitempty"`
	Port  *int32            `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	Tos   *int32            `protobuf:"varint,4,opt,name=tos" json:"tos,omitempty"`
	Ttl   *int32            `protobuf:"varint,5,opt,name=ttl" json:"ttl,omitempty"`
	Bytes *int64            `protobuf:"varint,6,opt,name=bytes" json:"bytes,omitempty"`
	// Some sniffers may be able to parse the number of acutal payload bytes
	ApplicationBytes *int64   `protobuf:"varint,7,opt,name=application_bytes,json=applicationBytes" json:"application_bytes,omitempty"`
	Packets          *int64   `protobuf:"varint,8,opt,name=packets" json:"packets,omitempty"`
	Loss             *float32 `protobuf:"fixed32,9,opt,name=loss" json:"loss,omitempty"`
	// ---------- ICMP ----------
	Type            *int32 `protobuf:"varint,10,opt,name=type" json:"type,omitempty"`
	Code            *int32 `protobuf:"varint,11,opt,name=code" json:"code,omitempty"`
	Id              *int32 `protobuf:"varint,12,opt,name=id" json:"id,omitempty"`
	Retransmissions *int64 `protobuf:"varint,13,opt,name=retransmissions" json:"retransmissions,omitempty"`
	// The vlan_id of the packet, empty if no vlan header.
	VlanId *int32 `protobuf:"varint,14,opt,name=vlan_id,json=vlanId" json:"vlan_id,omitempty"`
	// The L2 source addresses on which we observed this flow
	SourceMac [][]byte `protobuf:"bytes,15,rep,name=source_mac,json=sourceMac" json:"source_mac,omitempty"`
	// The L2 destination addresses that were affixed to this flow
	DestinationMac [][]byte `protobuf:"bytes,16,rep,name=destination_mac,json=destinationMac" json:"destination_mac,omitempty"`
	// The physical port id(s) on which we received/sent this flow.
	PhysicalPortNumber []int32 `protobuf:"varint,17,rep,name=physical_port_number,json=physicalPortNumber" json:"physical_port_number,omitempty"`
	// If the intercepted packet is a gre packet, place the key here.
	GreKey *uint32 `protobuf:"varint,18,opt,name=gre_key,json=greKey" json:"gre_key,omitempty"`
	// If we are looking at a tunneled protocol store the inner flow information
	// here. Note, this is typically the really interesting address.
	InnerAddress *IPAddressWrapper `protobuf:"bytes,19,opt,name=inner_address,json=innerAddress" json:"inner_address,omitempty"`
	InnerPort    *IPAddressWrapper `protobuf:"bytes,20,opt,name=inner_port,json=innerPort" json:"inner_port,omitempty"`
	// as in IPPROTO_*
	InnerProtocol *IPAddressWrapper `protobuf:"bytes,21,opt,name=inner_protocol,json=innerProtocol" json:"inner_protocol,omitempty"`
	// We may get richer flow information, e.g., decorated with pcap info.
	// We store additional information on a per-packet basis in the
	// sequence of pcap_decoration(s) below
	// Timestamps in these are relative to the timestamp of the record.
	// Decoration is most meaningful if the flow describes something
	// like a single connection. But this is not a requirement. If we
	// get netflow records we don't get the pcap information.
	PacketDecor      []*PacketData `protobuf:"bytes,22,rep,name=packet_decor,json=packetDecor" json:"packet_decor,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *IPFlow) Reset()                    { *m = IPFlow{} }
func (m *IPFlow) String() string            { return proto.CompactTextString(m) }
func (*IPFlow) ProtoMessage()               {}
func (*IPFlow) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *IPFlow) GetAddress() *IPAddressWrapper {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *IPFlow) GetMask() *IPAddressWrapper {
	if m != nil {
		return m.Mask
	}
	return nil
}

func (m *IPFlow) GetPort() int32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *IPFlow) GetTos() int32 {
	if m != nil && m.Tos != nil {
		return *m.Tos
	}
	return 0
}

func (m *IPFlow) GetTtl() int32 {
	if m != nil && m.Ttl != nil {
		return *m.Ttl
	}
	return 0
}

func (m *IPFlow) GetBytes() int64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

func (m *IPFlow) GetApplicationBytes() int64 {
	if m != nil && m.ApplicationBytes != nil {
		return *m.ApplicationBytes
	}
	return 0
}

func (m *IPFlow) GetPackets() int64 {
	if m != nil && m.Packets != nil {
		return *m.Packets
	}
	return 0
}

func (m *IPFlow) GetLoss() float32 {
	if m != nil && m.Loss != nil {
		return *m.Loss
	}
	return 0
}

func (m *IPFlow) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *IPFlow) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *IPFlow) GetId() int32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *IPFlow) GetRetransmissions() int64 {
	if m != nil && m.Retransmissions != nil {
		return *m.Retransmissions
	}
	return 0
}

func (m *IPFlow) GetVlanId() int32 {
	if m != nil && m.VlanId != nil {
		return *m.VlanId
	}
	return 0
}

func (m *IPFlow) GetSourceMac() [][]byte {
	if m != nil {
		return m.SourceMac
	}
	return nil
}

func (m *IPFlow) GetDestinationMac() [][]byte {
	if m != nil {
		return m.DestinationMac
	}
	return nil
}

func (m *IPFlow) GetPhysicalPortNumber() []int32 {
	if m != nil {
		return m.PhysicalPortNumber
	}
	return nil
}

func (m *IPFlow) GetGreKey() uint32 {
	if m != nil && m.GreKey != nil {
		return *m.GreKey
	}
	return 0
}

func (m *IPFlow) GetInnerAddress() *IPAddressWrapper {
	if m != nil {
		return m.InnerAddress
	}
	return nil
}

func (m *IPFlow) GetInnerPort() *IPAddressWrapper {
	if m != nil {
		return m.InnerPort
	}
	return nil
}

func (m *IPFlow) GetInnerProtocol() *IPAddressWrapper {
	if m != nil {
		return m.InnerProtocol
	}
	return nil
}

func (m *IPFlow) GetPacketDecor() []*PacketData {
	if m != nil {
		return m.PacketDecor
	}
	return nil
}

type FlowRecord struct {
	// which capture was responsible for this record.
	CaptureSpecId *int32 `protobuf:"varint,1,req,name=capture_spec_id,json=captureSpecId" json:"capture_spec_id,omitempty"`
	// seconds since epoch : deprecated use top-level instead
	TimestampSeconds *int64 `protobuf:"varint,2,opt,name=timestamp_seconds,json=timestampSeconds" json:"timestamp_seconds,omitempty"`
	// really required
	TimestampNs *uint32 `protobuf:"varint,3,opt,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	// if duration is not set then the flow-record is incomplete, i.e.,
	// the flow was started but hasn't terminated. If the record is
	// an aggregate count of many individual records then we set
	// bucket_duration_us instead of this value.
	// The field is also unset if this is a single packet.
	DurationUs *int64              `protobuf:"varint,4,opt,name=duration_us,json=durationUs" json:"duration_us,omitempty"`
	L2Proto    *FlowRecord_L2Proto `protobuf:"varint,5,opt,name=l2_proto,json=l2Proto,enum=nofutz.FlowMinder.FlowRecord_L2Proto,def=1" json:"l2_proto,omitempty"`
	// L3 protocol is recorded as ETHERTYPE
	L3Proto     *int32  `protobuf:"varint,6,opt,name=l3_proto,json=l3Proto" json:"l3_proto,omitempty"`
	L4Proto     *int32  `protobuf:"varint,7,opt,name=l4_proto,json=l4Proto" json:"l4_proto,omitempty"`
	Source      *IPFlow `protobuf:"bytes,8,opt,name=source" json:"source,omitempty"`
	Destination *IPFlow `protobuf:"bytes,9,opt,name=destination" json:"destination,omitempty"`
	// The number of individual flow records that have
	// been rolled up into this entry.
	NumberOfAggregatedFlows *int64 `protobuf:"varint,10,opt,name=number_of_aggregated_flows,json=numberOfAggregatedFlows,def=1" json:"number_of_aggregated_flows,omitempty"`
	// If we roll up many individual flows into one single bucket
	// then we need to state the duration of our bucket.
	BucketDurationUs *int64 `protobuf:"varint,11,opt,name=bucket_duration_us,json=bucketDurationUs" json:"bucket_duration_us,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *FlowRecord) Reset()                    { *m = FlowRecord{} }
func (m *FlowRecord) String() string            { return proto.CompactTextString(m) }
func (*FlowRecord) ProtoMessage()               {}
func (*FlowRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

const Default_FlowRecord_L2Proto FlowRecord_L2Proto = FlowRecord_L2_ETHERNET
const Default_FlowRecord_NumberOfAggregatedFlows int64 = 1

func (m *FlowRecord) GetCaptureSpecId() int32 {
	if m != nil && m.CaptureSpecId != nil {
		return *m.CaptureSpecId
	}
	return 0
}

func (m *FlowRecord) GetTimestampSeconds() int64 {
	if m != nil && m.TimestampSeconds != nil {
		return *m.TimestampSeconds
	}
	return 0
}

func (m *FlowRecord) GetTimestampNs() uint32 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *FlowRecord) GetDurationUs() int64 {
	if m != nil && m.DurationUs != nil {
		return *m.DurationUs
	}
	return 0
}

func (m *FlowRecord) GetL2Proto() FlowRecord_L2Proto {
	if m != nil && m.L2Proto != nil {
		return *m.L2Proto
	}
	return Default_FlowRecord_L2Proto
}

func (m *FlowRecord) GetL3Proto() int32 {
	if m != nil && m.L3Proto != nil {
		return *m.L3Proto
	}
	return 0
}

func (m *FlowRecord) GetL4Proto() int32 {
	if m != nil && m.L4Proto != nil {
		return *m.L4Proto
	}
	return 0
}

func (m *FlowRecord) GetSource() *IPFlow {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *FlowRecord) GetDestination() *IPFlow {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *FlowRecord) GetNumberOfAggregatedFlows() int64 {
	if m != nil && m.NumberOfAggregatedFlows != nil {
		return *m.NumberOfAggregatedFlows
	}
	return Default_FlowRecord_NumberOfAggregatedFlows
}

func (m *FlowRecord) GetBucketDurationUs() int64 {
	if m != nil && m.BucketDurationUs != nil {
		return *m.BucketDurationUs
	}
	return 0
}

// Make sure BGP-specific sub-structs(messages) stay within the BgpRecord
// message for discussion on this struct refer to:
// https://docs.google.com/document
// /d/1h_2sV89y2n2nTK4upU_XNw-fUX0uORorh8V8itZZZ-Q/edit
type BgpRecord struct {
	// these should be set  from the BGP header.
	TimestampSeconds *int64  `protobuf:"varint,1,opt,name=timestamp_seconds,json=timestampSeconds" json:"timestamp_seconds,omitempty"`
	TimestampNs      *uint32 `protobuf:"varint,2,opt,name=timestamp_ns,json=timestampNs" json:"timestamp_ns,omitempty"`
	// this normally should be the same as the Router ID in the BGP message
	// but there are misconfigured machines that don't follow that
	// rule. So this is the interface ip.
	CollectorIp *IPAddressWrapper `protobuf:"bytes,3,opt,name=collector_ip,json=collectorIp" json:"collector_ip,omitempty"`
	// in case we know the MAC address of our BGP collector
	CollectorMac [][]byte `protobuf:"bytes,4,rep,name=collector_mac,json=collectorMac" json:"collector_mac,omitempty"`
	// in case we know the physical port on the switch the BGP router is
	CollectorPort *int32 `protobuf:"varint,5,opt,name=collector_port,json=collectorPort" json:"collector_port,omitempty"`
	// the IP of the peer that sent this captured BGP message. required
	PeerIp *IPAddressWrapper `protobuf:"bytes,6,opt,name=peer_ip,json=peerIp" json:"peer_ip,omitempty"`
	// a message can contain both of the following fields.
	AdvertizedRoutes *BgpRecord_AdvertizedRoutes `protobuf:"bytes,7,opt,name=advertized_routes,json=advertizedRoutes" json:"advertized_routes,omitempty"`
	WithdrawnRoutes  *BgpRecord_WithdrawnRoutes  `protobuf:"bytes,8,opt,name=withdrawn_routes,json=withdrawnRoutes" json:"withdrawn_routes,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *BgpRecord) Reset()                    { *m = BgpRecord{} }
func (m *BgpRecord) String() string            { return proto.CompactTextString(m) }
func (*BgpRecord) ProtoMessage()               {}
func (*BgpRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *BgpRecord) GetTimestampSeconds() int64 {
	if m != nil && m.TimestampSeconds != nil {
		return *m.TimestampSeconds
	}
	return 0
}

func (m *BgpRecord) GetTimestampNs() uint32 {
	if m != nil && m.TimestampNs != nil {
		return *m.TimestampNs
	}
	return 0
}

func (m *BgpRecord) GetCollectorIp() *IPAddressWrapper {
	if m != nil {
		return m.CollectorIp
	}
	return nil
}

func (m *BgpRecord) GetCollectorMac() [][]byte {
	if m != nil {
		return m.CollectorMac
	}
	return nil
}

func (m *BgpRecord) GetCollectorPort() int32 {
	if m != nil && m.CollectorPort != nil {
		return *m.CollectorPort
	}
	return 0
}

func (m *BgpRecord) GetPeerIp() *IPAddressWrapper {
	if m != nil {
		return m.PeerIp
	}
	return nil
}

func (m *BgpRecord) GetAdvertizedRoutes() *BgpRecord_AdvertizedRoutes {
	if m != nil {
		return m.AdvertizedRoutes
	}
	return nil
}

func (m *BgpRecord) GetWithdrawnRoutes() *BgpRecord_WithdrawnRoutes {
	if m != nil {
		return m.WithdrawnRoutes
	}
	return nil
}

type BgpRecord_PrefixWrapper struct {
	// both are really required
	Prefix           *IPAddressWrapper `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Mask             *int32            `protobuf:"varint,2,opt,name=mask" json:"mask,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *BgpRecord_PrefixWrapper) Reset()                    { *m = BgpRecord_PrefixWrapper{} }
func (m *BgpRecord_PrefixWrapper) String() string            { return proto.CompactTextString(m) }
func (*BgpRecord_PrefixWrapper) ProtoMessage()               {}
func (*BgpRecord_PrefixWrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

func (m *BgpRecord_PrefixWrapper) GetPrefix() *IPAddressWrapper {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *BgpRecord_PrefixWrapper) GetMask() int32 {
	if m != nil && m.Mask != nil {
		return *m.Mask
	}
	return 0
}

// an AS-path is a sequence of either subsequences of AS-Paths (lists)
// or Sets of ASes. We call either of those, segments.
type BgpRecord_ASPathSegment struct {
	AsSet            []uint32 `protobuf:"varint,1,rep,name=as_set,json=asSet" json:"as_set,omitempty"`
	AsSeq            []uint32 `protobuf:"varint,2,rep,name=as_seq,json=asSeq" json:"as_seq,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *BgpRecord_ASPathSegment) Reset()                    { *m = BgpRecord_ASPathSegment{} }
func (m *BgpRecord_ASPathSegment) String() string            { return proto.CompactTextString(m) }
func (*BgpRecord_ASPathSegment) ProtoMessage()               {}
func (*BgpRecord_ASPathSegment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 1} }

func (m *BgpRecord_ASPathSegment) GetAsSet() []uint32 {
	if m != nil {
		return m.AsSet
	}
	return nil
}

func (m *BgpRecord_ASPathSegment) GetAsSeq() []uint32 {
	if m != nil {
		return m.AsSeq
	}
	return nil
}

// if this is populated then all the attrs in it are RFC-mandatory,
// so required.
type BgpRecord_AdvertizedRoutes struct {
	Prefixes         []*BgpRecord_PrefixWrapper `protobuf:"bytes,1,rep,name=prefixes" json:"prefixes,omitempty"`
	AsPath           []*BgpRecord_ASPathSegment `protobuf:"bytes,2,rep,name=as_path,json=asPath" json:"as_path,omitempty"`
	NextHop          *IPAddressWrapper          `protobuf:"bytes,3,opt,name=next_hop,json=nextHop" json:"next_hop,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *BgpRecord_AdvertizedRoutes) Reset()                    { *m = BgpRecord_AdvertizedRoutes{} }
func (m *BgpRecord_AdvertizedRoutes) String() string            { return proto.CompactTextString(m) }
func (*BgpRecord_AdvertizedRoutes) ProtoMessage()               {}
func (*BgpRecord_AdvertizedRoutes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 2} }

func (m *BgpRecord_AdvertizedRoutes) GetPrefixes() []*BgpRecord_PrefixWrapper {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

func (m *BgpRecord_AdvertizedRoutes) GetAsPath() []*BgpRecord_ASPathSegment {
	if m != nil {
		return m.AsPath
	}
	return nil
}

func (m *BgpRecord_AdvertizedRoutes) GetNextHop() *IPAddressWrapper {
	if m != nil {
		return m.NextHop
	}
	return nil
}

type BgpRecord_WithdrawnRoutes struct {
	Prefixes         []*BgpRecord_PrefixWrapper `protobuf:"bytes,1,rep,name=prefixes" json:"prefixes,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *BgpRecord_WithdrawnRoutes) Reset()                    { *m = BgpRecord_WithdrawnRoutes{} }
func (m *BgpRecord_WithdrawnRoutes) String() string            { return proto.CompactTextString(m) }
func (*BgpRecord_WithdrawnRoutes) ProtoMessage()               {}
func (*BgpRecord_WithdrawnRoutes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 3} }

func (m *BgpRecord_WithdrawnRoutes) GetPrefixes() []*BgpRecord_PrefixWrapper {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

type DNSRecord struct {
	RequestingHost *IPAddressWrapper `protobuf:"bytes,1,opt,name=requesting_host,json=requestingHost" json:"requesting_host,omitempty"`
	DnsServer      *IPAddressWrapper `protobuf:"bytes,2,opt,name=dns_server,json=dnsServer" json:"dns_server,omitempty"`
	// The replies
	Ips   []*IPAddressWrapper `protobuf:"bytes,3,rep,name=ips" json:"ips,omitempty"`
	Cname []string            `protobuf:"bytes,4,rep,name=cname" json:"cname,omitempty"`
	// The original question
	Query *string `protobuf:"bytes,5,opt,name=query" json:"query,omitempty"`
	// Is the reply in DNSSec form
	Dnssec           *bool  `protobuf:"varint,6,opt,name=dnssec" json:"dnssec,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DNSRecord) Reset()                    { *m = DNSRecord{} }
func (m *DNSRecord) String() string            { return proto.CompactTextString(m) }
func (*DNSRecord) ProtoMessage()               {}
func (*DNSRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DNSRecord) GetRequestingHost() *IPAddressWrapper {
	if m != nil {
		return m.RequestingHost
	}
	return nil
}

func (m *DNSRecord) GetDnsServer() *IPAddressWrapper {
	if m != nil {
		return m.DnsServer
	}
	return nil
}

func (m *DNSRecord) GetIps() []*IPAddressWrapper {
	if m != nil {
		return m.Ips
	}
	return nil
}

func (m *DNSRecord) GetCname() []string {
	if m != nil {
		return m.Cname
	}
	return nil
}

func (m *DNSRecord) GetQuery() string {
	if m != nil && m.Query != nil {
		return *m.Query
	}
	return ""
}

func (m *DNSRecord) GetDnssec() bool {
	if m != nil && m.Dnssec != nil {
		return *m.Dnssec
	}
	return false
}

// Should contain either a capture_spec or a record. This gives us
// the ability to parse consecutive records flexibly. The record contains
// only one of the fields, namely the one identified by record_type.
// A capture spec is a meta-record meant to describe the file at hand.
type CaptureRecordUnion struct {
	// Rough timestamp for indexing or filtering of data. May be
	// augmented internally.  In UTC since epoch.
	TimestampSeconds *int64 `protobuf:"varint,1,opt,name=timestamp_seconds,json=timestampSeconds" json:"timestamp_seconds,omitempty"`
	// These addreses are index keys.
	Sip *IPAddressWrapper `protobuf:"bytes,2,opt,name=sip" json:"sip,omitempty"`
	Dip *IPAddressWrapper `protobuf:"bytes,3,opt,name=dip" json:"dip,omitempty"`
	// If masks are omitted then the dip/sip is
	// interpreted as a specific ip (not a net)
	SipMask          *IPAddressWrapper              `protobuf:"bytes,4,opt,name=sip_mask,json=sipMask" json:"sip_mask,omitempty"`
	DipMask          *IPAddressWrapper              `protobuf:"bytes,5,opt,name=dip_mask,json=dipMask" json:"dip_mask,omitempty"`
	RecordType       *CaptureRecordUnion_RecordType `protobuf:"varint,6,opt,name=record_type,json=recordType,enum=nofutz.FlowMinder.CaptureRecordUnion_RecordType" json:"record_type,omitempty"`
	CaptureSpec      *CaptureSpec                   `protobuf:"bytes,7,opt,name=capture_spec,json=captureSpec" json:"capture_spec,omitempty"`
	FlowRecord       *FlowRecord                    `protobuf:"bytes,8,opt,name=flow_record,json=flowRecord" json:"flow_record,omitempty"`
	BgpRecord        *BgpRecord                     `protobuf:"bytes,9,opt,name=bgp_record,json=bgpRecord" json:"bgp_record,omitempty"`
	DnsRecord        *DNSRecord                     `protobuf:"bytes,10,opt,name=dns_record,json=dnsRecord" json:"dns_record,omitempty"`
	XXX_unrecognized []byte                         `json:"-"`
}

func (m *CaptureRecordUnion) Reset()                    { *m = CaptureRecordUnion{} }
func (m *CaptureRecordUnion) String() string            { return proto.CompactTextString(m) }
func (*CaptureRecordUnion) ProtoMessage()               {}
func (*CaptureRecordUnion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CaptureRecordUnion) GetTimestampSeconds() int64 {
	if m != nil && m.TimestampSeconds != nil {
		return *m.TimestampSeconds
	}
	return 0
}

func (m *CaptureRecordUnion) GetSip() *IPAddressWrapper {
	if m != nil {
		return m.Sip
	}
	return nil
}

func (m *CaptureRecordUnion) GetDip() *IPAddressWrapper {
	if m != nil {
		return m.Dip
	}
	return nil
}

func (m *CaptureRecordUnion) GetSipMask() *IPAddressWrapper {
	if m != nil {
		return m.SipMask
	}
	return nil
}

func (m *CaptureRecordUnion) GetDipMask() *IPAddressWrapper {
	if m != nil {
		return m.DipMask
	}
	return nil
}

func (m *CaptureRecordUnion) GetRecordType() CaptureRecordUnion_RecordType {
	if m != nil && m.RecordType != nil {
		return *m.RecordType
	}
	return CaptureRecordUnion_CAPTURE_SPEC
}

func (m *CaptureRecordUnion) GetCaptureSpec() *CaptureSpec {
	if m != nil {
		return m.CaptureSpec
	}
	return nil
}

func (m *CaptureRecordUnion) GetFlowRecord() *FlowRecord {
	if m != nil {
		return m.FlowRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetBgpRecord() *BgpRecord {
	if m != nil {
		return m.BgpRecord
	}
	return nil
}

func (m *CaptureRecordUnion) GetDnsRecord() *DNSRecord {
	if m != nil {
		return m.DnsRecord
	}
	return nil
}

func init() {
	proto.RegisterType((*CaptureSpec)(nil), "nofutz.FlowMinder.CaptureSpec")
	proto.RegisterType((*IPAddressWrapper)(nil), "nofutz.FlowMinder.IPAddressWrapper")
	proto.RegisterType((*PacketData)(nil), "nofutz.FlowMinder.PacketData")
	proto.RegisterType((*IPFlow)(nil), "nofutz.FlowMinder.IPFlow")
	proto.RegisterType((*FlowRecord)(nil), "nofutz.FlowMinder.FlowRecord")
	proto.RegisterType((*BgpRecord)(nil), "nofutz.FlowMinder.BgpRecord")
	proto.RegisterType((*BgpRecord_PrefixWrapper)(nil), "nofutz.FlowMinder.BgpRecord.PrefixWrapper")
	proto.RegisterType((*BgpRecord_ASPathSegment)(nil), "nofutz.FlowMinder.BgpRecord.ASPathSegment")
	proto.RegisterType((*BgpRecord_AdvertizedRoutes)(nil), "nofutz.FlowMinder.BgpRecord.AdvertizedRoutes")
	proto.RegisterType((*BgpRecord_WithdrawnRoutes)(nil), "nofutz.FlowMinder.BgpRecord.WithdrawnRoutes")
	proto.RegisterType((*DNSRecord)(nil), "nofutz.FlowMinder.DNSRecord")
	proto.RegisterType((*CaptureRecordUnion)(nil), "nofutz.FlowMinder.CaptureRecordUnion")
	proto.RegisterEnum("nofutz.FlowMinder.CaptureSpec_Type", CaptureSpec_Type_name, CaptureSpec_Type_value)
	proto.RegisterEnum("nofutz.FlowMinder.FlowRecord_L2Proto", FlowRecord_L2Proto_name, FlowRecord_L2Proto_value)
	proto.RegisterEnum("nofutz.FlowMinder.CaptureRecordUnion_RecordType", CaptureRecordUnion_RecordType_name, CaptureRecordUnion_RecordType_value)
}

func init() { proto.RegisterFile("flow-record.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0xe9, 0x72, 0x1b, 0xc7,
	0x11, 0x0e, 0x89, 0xbb, 0x71, 0x10, 0x1c, 0x1d, 0x5e, 0xb3, 0xa2, 0x44, 0x81, 0xcb, 0xb1, 0x7c,
	0x88, 0x65, 0x83, 0x8c, 0x53, 0x25, 0xc5, 0xae, 0xf0, 0x00, 0x23, 0x26, 0x3c, 0x90, 0x01, 0x15,
	0x55, 0xf2, 0x67, 0xb3, 0xc4, 0x0e, 0xc8, 0x2d, 0x01, 0xbb, 0xab, 0x9d, 0x85, 0x28, 0xfa, 0x49,
	0xf2, 0x1a, 0x79, 0x83, 0x3c, 0x42, 0xaa, 0x92, 0xff, 0x7e, 0x95, 0x74, 0xf7, 0x0c, 0x16, 0x20,
	0x44, 0x31, 0x40, 0x95, 0xff, 0xcd, 0x7c, 0xdd, 0x5f, 0xef, 0x4c, 0x4f, 0x4f, 0x77, 0xcf, 0xc2,
	0xfa, 0x60, 0x18, 0x5d, 0x3d, 0x4d, 0x54, 0x3f, 0x4a, 0xfc, 0xcd, 0x38, 0x89, 0xd2, 0x48, 0xac,
	0x87, 0xd1, 0x60, 0x9c, 0xfe, 0xb0, 0x79, 0x80, 0x92, 0xe3, 0x20, 0xf4, 0x55, 0xd2, 0xfa, 0x6f,
	0x01, 0xaa, 0x7b, 0x5e, 0x9c, 0x8e, 0x13, 0xd5, 0x8b, 0x55, 0x5f, 0xfc, 0x1a, 0xd6, 0xfa, 0x66,
	0xea, 0x6a, 0x9c, 0xbb, 0x81, 0xef, 0xac, 0x3c, 0x5e, 0x7d, 0x52, 0x90, 0xf5, 0xfe, 0x54, 0xeb,
	0xd0, 0x17, 0x4f, 0xa0, 0xf9, 0x56, 0x25, 0xe7, 0x91, 0x56, 0xae, 0xaf, 0xce, 0xc7, 0x17, 0xa4,
	0x58, 0x7b, 0xbc, 0xf2, 0xa4, 0x26, 0x1b, 0x16, 0xdf, 0x27, 0x18, 0x35, 0xbf, 0x83, 0x7c, 0x7a,
	0x1d, 0x2b, 0xa7, 0x81, 0xd2, 0x46, 0xfb, 0x93, 0xcd, 0xf7, 0xd6, 0xb0, 0x39, 0xf3, 0xfd, 0xcd,
	0x33, 0x54, 0x7d, 0x96, 0x3f, 0x38, 0x3a, 0x7d, 0x25, 0x99, 0x26, 0x9e, 0x82, 0x48, 0xfb, 0xb1,
	0x3f, 0x1e, 0xc5, 0xae, 0x7a, 0x17, 0x27, 0x4a, 0xeb, 0x20, 0x0a, 0x9d, 0x55, 0x34, 0x56, 0x91,
	0xeb, 0x56, 0xd2, 0xc9, 0x04, 0xe2, 0x73, 0x68, 0x4e, 0xd6, 0x3f, 0x8c, 0xfa, 0x5e, 0x4a, 0xca,
	0x39, 0x56, 0x9e, 0xec, 0xeb, 0xc8, 0xc2, 0xa2, 0x07, 0xf7, 0xe6, 0x55, 0xdd, 0x20, 0x76, 0xf2,
	0xa8, 0x5d, 0xbd, 0x75, 0x9d, 0x87, 0xdd, 0x1d, 0xdf, 0xa7, 0x0f, 0xbd, 0x4a, 0xbc, 0x38, 0x56,
	0x89, 0x5c, 0x9f, 0x33, 0x79, 0x18, 0x8b, 0xaf, 0xe1, 0xfe, 0x7b, 0x46, 0xfd, 0x50, 0x3b, 0x05,
	0x5e, 0x83, 0x98, 0x23, 0xec, 0x87, 0x5a, 0x7c, 0x01, 0x13, 0x33, 0x6e, 0x18, 0xf9, 0xc6, 0xed,
	0x4e, 0xf1, 0xc6, 0x92, 0x4f, 0x10, 0xe7, 0xd3, 0xd9, 0x86, 0x87, 0x37, 0x74, 0x83, 0x30, 0x55,
	0xc9, 0xc0, 0xeb, 0x2b, 0xa7, 0xf4, 0x38, 0x87, 0x84, 0xfb, 0x33, 0x84, 0xc3, 0x89, 0x4c, 0x7c,
	0x0f, 0xe5, 0x38, 0x8d, 0xdd, 0x58, 0xa9, 0xc4, 0xa9, 0x2f, 0xbe, 0xbb, 0x12, 0x92, 0xba, 0xc8,
	0x11, 0xbf, 0x82, 0x9a, 0x4e, 0xa3, 0xc4, 0xbb, 0x50, 0xee, 0x65, 0xa4, 0x53, 0xa7, 0xcc, 0xdf,
	0xaa, 0x5a, 0xec, 0x05, 0x42, 0xa2, 0x05, 0xf5, 0xd8, 0x4b, 0x2f, 0xdd, 0x34, 0x72, 0x07, 0xc1,
	0x50, 0x69, 0xa7, 0x62, 0x74, 0x08, 0x3c, 0x8b, 0x0e, 0x08, 0x22, 0x33, 0x24, 0x73, 0x11, 0xc3,
	0x95, 0x85, 0x0e, 0x18, 0x15, 0xc2, 0xba, 0x06, 0x12, 0x1b, 0x50, 0x1e, 0x6b, 0x1c, 0x78, 0x23,
	0xe5, 0x54, 0xd9, 0x05, 0xd9, 0xbc, 0xf5, 0x25, 0xe4, 0x29, 0x38, 0x44, 0x19, 0x38, 0x3c, 0x9a,
	0x2b, 0xa2, 0x0a, 0xa5, 0xdd, 0x3f, 0x74, 0xdd, 0x63, 0x79, 0xd6, 0x5c, 0x15, 0x35, 0x28, 0xd3,
	0xe4, 0xe8, 0xf0, 0x2f, 0x9d, 0x66, 0xbe, 0xf5, 0x0c, 0x9a, 0xf3, 0xfb, 0x11, 0x02, 0xf2, 0x41,
	0xfc, 0x76, 0x1b, 0xe3, 0x99, 0xc2, 0x94, 0xc7, 0x16, 0xfb, 0x96, 0xe3, 0xc9, 0x60, 0xdf, 0xb6,
	0x7e, 0x5c, 0x05, 0xe8, 0x7a, 0xfd, 0xd7, 0x2a, 0xdd, 0xf7, 0x52, 0x4f, 0x6c, 0xc1, 0xc3, 0xd0,
	0x0b, 0x23, 0xed, 0xea, 0x20, 0xec, 0x2b, 0x97, 0x6e, 0x95, 0xab, 0x53, 0x2f, 0x49, 0xd9, 0x50,
	0x5e, 0xde, 0x63, 0x69, 0x8f, 0x84, 0xe4, 0xcd, 0x1e, 0x89, 0xc4, 0x2f, 0x01, 0xb7, 0x4e, 0x26,
	0x90, 0xf5, 0x83, 0x62, 0xf3, 0x75, 0x09, 0x06, 0xea, 0x21, 0x22, 0xee, 0x41, 0x21, 0x88, 0xe9,
	0xd2, 0xe4, 0x58, 0x84, 0x5f, 0xc6, 0xab, 0x82, 0xac, 0x40, 0xbb, 0x03, 0xf4, 0xea, 0x48, 0x85,
	0x29, 0x47, 0x62, 0x59, 0x42, 0xa0, 0x0f, 0x2c, 0x42, 0x0a, 0x57, 0x78, 0x5a, 0xb4, 0x02, 0x32,
	0x4b, 0x41, 0x55, 0x90, 0x60, 0x20, 0x36, 0x8b, 0x0e, 0xd4, 0xea, 0xcd, 0x58, 0xe1, 0x62, 0x38,
	0x86, 0xea, 0x32, 0x9b, 0x8b, 0x26, 0xe4, 0xf0, 0xfb, 0x18, 0x29, 0x04, 0xd3, 0x90, 0x10, 0x7d,
	0x1d, 0xe2, 0x79, 0xd2, 0x77, 0x68, 0x48, 0xc8, 0x20, 0x08, 0xf1, 0xf4, 0x18, 0xc1, 0xa1, 0xb8,
	0x0f, 0x05, 0x74, 0xa2, 0x4a, 0xf1, 0xb8, 0x08, 0x33, 0x13, 0xf1, 0x08, 0x20, 0x8a, 0x29, 0x82,
	0xb5, 0x3b, 0xdc, 0xe2, 0xa3, 0x2a, 0xcb, 0x8a, 0x45, 0x8e, 0xb6, 0x6e, 0x88, 0xb7, 0x39, 0x2f,
	0xcc, 0x88, 0xb7, 0x5b, 0xff, 0x29, 0x42, 0xf1, 0xb0, 0x4b, 0xde, 0xc2, 0xec, 0x50, 0xf2, 0xcc,
	0x31, 0xb1, 0x3b, 0x17, 0x0d, 0x4d, 0xcb, 0x11, 0xbf, 0x85, 0xfc, 0xc8, 0xd3, 0xaf, 0xd9, 0xc1,
	0x0b, 0x72, 0x99, 0x40, 0x07, 0x1f, 0x47, 0x78, 0x86, 0x39, 0x76, 0x21, 0x8f, 0x69, 0xf3, 0x69,
	0xa4, 0xd9, 0xed, 0x05, 0x49, 0x43, 0x46, 0xd2, 0xa1, 0xf5, 0x33, 0x0d, 0xc9, 0x1d, 0xe7, 0xd7,
	0x29, 0x06, 0x38, 0x79, 0x37, 0x27, 0xcd, 0x44, 0x7c, 0x09, 0xeb, 0x68, 0x7c, 0x18, 0xd8, 0x0b,
	0x6f, 0x34, 0x4a, 0xac, 0xd1, 0x9c, 0x11, 0xec, 0xb2, 0xb2, 0x03, 0x25, 0x13, 0x08, 0x9a, 0x3d,
	0x9f, 0x93, 0x93, 0x29, 0x2d, 0x6a, 0x18, 0x69, 0xcd, 0xee, 0x5f, 0x95, 0x3c, 0x26, 0x8c, 0xd3,
	0x27, 0x98, 0x85, 0x72, 0x4e, 0x44, 0xac, 0x8f, 0x37, 0x9c, 0xfd, 0x8e, 0x18, 0x8d, 0x45, 0x03,
	0x56, 0x6d, 0x0a, 0x2e, 0x48, 0x1c, 0x61, 0x82, 0x5e, 0x4b, 0x54, 0x9a, 0x78, 0xa1, 0x1e, 0x05,
	0x9c, 0x1a, 0x35, 0xdf, 0xfd, 0x9c, 0x9c, 0x87, 0xc5, 0x47, 0x50, 0x7a, 0x3b, 0xf4, 0x42, 0x0a,
	0xc6, 0x06, 0xd3, 0x8b, 0x34, 0xc5, 0x70, 0xc4, 0x53, 0xd4, 0xd1, 0x38, 0xc1, 0xa0, 0x1f, 0x79,
	0x7d, 0x67, 0x0d, 0xaf, 0x6b, 0x4d, 0x56, 0x0c, 0x72, 0xec, 0xf5, 0xc5, 0x67, 0xb0, 0xe6, 0x2b,
	0x9d, 0x06, 0xa1, 0xd9, 0x34, 0xe9, 0x34, 0x59, 0xa7, 0x31, 0x03, 0x93, 0x22, 0xe6, 0xc4, 0xf8,
	0xf2, 0x5a, 0xa3, 0x13, 0x86, 0x2e, 0x39, 0xda, 0x0d, 0xc7, 0xa3, 0x73, 0xcc, 0x45, 0xeb, 0xa8,
	0x5d, 0x90, 0x62, 0x22, 0xeb, 0xa2, 0xe8, 0x84, 0x25, 0xb4, 0xa4, 0x0b, 0xcc, 0x71, 0xaf, 0xd5,
	0xb5, 0x23, 0x38, 0x5c, 0x8b, 0x38, 0xfd, 0x93, 0xba, 0x16, 0x2f, 0xa0, 0x1e, 0x84, 0xa1, 0x4a,
	0xdc, 0x49, 0xd0, 0xdc, 0x5b, 0xfc, 0xe0, 0x6b, 0xcc, 0xb4, 0xa0, 0xd8, 0x05, 0x30, 0x96, 0x38,
	0x0c, 0xee, 0x2f, 0x6e, 0xa6, 0xc2, 0x34, 0x5a, 0xac, 0xf8, 0x23, 0x34, 0xac, 0x0d, 0x2a, 0xaf,
	0xfd, 0x68, 0xe8, 0x3c, 0x58, 0xdc, 0x8e, 0xd9, 0x48, 0xd7, 0x32, 0xc5, 0xef, 0xa1, 0x66, 0x33,
	0x86, 0x4f, 0x25, 0xdb, 0x79, 0x88, 0xce, 0xa9, 0xb6, 0x1f, 0xdd, 0x62, 0x69, 0x9a, 0x9b, 0xa4,
	0x4d, 0x32, 0xfb, 0xc4, 0x68, 0xfd, 0x33, 0x0f, 0x40, 0x6a, 0x92, 0x4b, 0xfe, 0xc2, 0x95, 0x1c,
	0x63, 0x37, 0x0d, 0x46, 0x78, 0x62, 0x1e, 0x96, 0x58, 0x8d, 0xdc, 0xd0, 0xd7, 0x7c, 0x9f, 0x30,
	0x76, 0x33, 0x41, 0xcf, 0xe0, 0x94, 0xc3, 0xa7, 0xca, 0x18, 0x52, 0x26, 0x7b, 0x55, 0x33, 0xec,
	0x44, 0x53, 0x8e, 0xf2, 0xc7, 0x89, 0x89, 0x89, 0xb1, 0xb9, 0x4d, 0x39, 0x09, 0x13, 0xe8, 0xa5,
	0x16, 0xc7, 0x50, 0x1e, 0xb6, 0x8d, 0xcb, 0xf8, 0x66, 0x35, 0xda, 0x9f, 0xde, 0xb2, 0xcb, 0xe9,
	0x4e, 0x36, 0x8f, 0xda, 0xec, 0xa5, 0x67, 0xd5, 0xa3, 0xb6, 0xdb, 0x39, 0x7b, 0xd1, 0x91, 0x27,
	0x9d, 0x33, 0x59, 0x1a, 0x1a, 0x54, 0x7c, 0x8c, 0xe6, 0xb6, 0xac, 0xb9, 0x22, 0xc7, 0x6f, 0x69,
	0xb8, 0x35, 0x15, 0x6d, 0x5b, 0x51, 0xc9, 0x8a, 0xb6, 0x8d, 0xe8, 0x1b, 0x28, 0x9a, 0x48, 0xe6,
	0x3b, 0x58, 0x6d, 0x7f, 0x7c, 0xeb, 0x91, 0xf1, 0x22, 0xac, 0xa2, 0x78, 0x8e, 0x1b, 0x9b, 0x06,
	0x36, 0x5f, 0xd2, 0x3b, 0x79, 0xb3, 0xda, 0x58, 0x83, 0x37, 0x4c, 0xd4, 0xbb, 0xd1, 0xc0, 0xf5,
	0x2e, 0x30, 0x9c, 0x2f, 0xbc, 0x54, 0xf9, 0x5c, 0x4e, 0x34, 0x5f, 0xee, 0xdc, 0xb3, 0x95, 0x6f,
	0xe4, 0x47, 0x46, 0xe9, 0x74, 0xb0, 0x93, 0xa9, 0x90, 0x2d, 0x2d, 0xbe, 0x02, 0x71, 0x3e, 0x36,
	0xe1, 0x31, 0xe3, 0xdc, 0xaa, 0x39, 0x26, 0x23, 0xd9, 0xcf, 0x5c, 0xdc, 0xfa, 0x0c, 0x4a, 0xd6,
	0x69, 0x54, 0x24, 0xd1, 0x6d, 0x27, 0xa7, 0x27, 0x9d, 0xe6, 0xcf, 0xc4, 0x1a, 0xcc, 0xfa, 0xb0,
	0xb9, 0xd2, 0xfa, 0x57, 0x09, 0x2a, 0xbb, 0x17, 0xb1, 0x0d, 0x99, 0x5b, 0x43, 0x61, 0x65, 0xc1,
	0x50, 0x58, 0x7d, 0x3f, 0x14, 0x0e, 0xa0, 0x86, 0xa1, 0x3d, 0x54, 0x7d, 0xec, 0x14, 0xa8, 0xb5,
	0xca, 0x2d, 0x7e, 0x3b, 0xaa, 0x19, 0x11, 0x9b, 0xaa, 0x4f, 0xa0, 0x3e, 0xb5, 0x43, 0x79, 0x26,
	0xcf, 0x79, 0x66, 0x6a, 0x9c, 0xb2, 0xcc, 0xa7, 0xd0, 0x98, 0x2a, 0xf1, 0xa5, 0x36, 0x69, 0x7b,
	0x4a, 0xe5, 0x3b, 0xfb, 0x3b, 0xcc, 0xbe, 0xd8, 0xd4, 0xd0, 0x72, 0x8a, 0x8b, 0x2f, 0xa7, 0x48,
	0x1c, 0x5c, 0xc9, 0xdf, 0x30, 0xd1, 0xfb, 0xd8, 0xe0, 0xa6, 0x58, 0x6c, 0x7d, 0x37, 0x89, 0xc6,
	0x93, 0x44, 0x5f, 0x6d, 0x3f, 0xbd, 0xc5, 0x4e, 0xe6, 0xda, 0xcd, 0x9d, 0x8c, 0x25, 0x99, 0x84,
	0x75, 0x61, 0x0e, 0x11, 0xaf, 0xa0, 0x79, 0x15, 0xa4, 0x97, 0x7e, 0xe2, 0x5d, 0x85, 0x13, 0xd3,
	0x26, 0x38, 0xbf, 0xba, 0xd3, 0xf4, 0xab, 0x09, 0xc9, 0x5a, 0x5e, 0xbb, 0xba, 0x09, 0x6c, 0xfc,
	0x1d, 0xea, 0xdd, 0x44, 0x0d, 0x82, 0x77, 0x93, 0x4e, 0xe8, 0x39, 0x14, 0x63, 0x06, 0x96, 0xa9,
	0xb9, 0x96, 0x42, 0xc5, 0x27, 0x2b, 0xb9, 0x05, 0x53, 0x4d, 0x37, 0xbe, 0x83, 0xfa, 0x4e, 0x0f,
	0x9b, 0xb8, 0xcb, 0x9e, 0x32, 0x8d, 0xca, 0x03, 0x28, 0x7a, 0xd8, 0x31, 0x29, 0x6a, 0x92, 0x72,
	0x18, 0x16, 0x05, 0x4f, 0xf7, 0xd4, 0x14, 0x7e, 0x83, 0xec, 0x0c, 0x7e, 0xb3, 0xf1, 0xe3, 0x0a,
	0x34, 0xe7, 0x1d, 0x84, 0xc1, 0x53, 0x36, 0x5f, 0x54, 0x9a, 0x8d, 0x54, 0xdb, 0x5f, 0xdc, 0xe9,
	0x86, 0x1b, 0x5b, 0x94, 0x19, 0x57, 0xec, 0x61, 0x87, 0xa1, 0xa9, 0xe9, 0xbc, 0xe4, 0x8f, 0xfe,
	0x3f, 0x33, 0x37, 0xf6, 0x21, 0x71, 0xb9, 0x34, 0xa5, 0x16, 0x3a, 0x54, 0xef, 0x52, 0xec, 0x7f,
	0x97, 0x8a, 0xe2, 0x12, 0x91, 0x5e, 0x44, 0xf1, 0xc6, 0x5f, 0x61, 0x6d, 0xee, 0x98, 0x7e, 0xaa,
	0xfd, 0xb5, 0xfe, 0xb1, 0x0a, 0x95, 0xfd, 0x93, 0x9e, 0xbd, 0xc2, 0x47, 0x54, 0xf6, 0xb1, 0xe1,
	0xa3, 0xcc, 0x73, 0x61, 0xda, 0xf5, 0x25, 0xce, 0xb8, 0x31, 0xe5, 0x72, 0x5b, 0x8f, 0x45, 0x12,
	0x1f, 0x2f, 0x78, 0x60, 0x09, 0x1e, 0xce, 0x32, 0x4d, 0x56, 0x05, 0x69, 0x3d, 0x66, 0x89, 0xdf,
	0x40, 0x2e, 0x88, 0xa9, 0x52, 0xe4, 0x16, 0x25, 0x93, 0x3e, 0x35, 0x5a, 0x7d, 0x7e, 0x07, 0xe4,
	0xf9, 0x99, 0x60, 0x26, 0x84, 0xe2, 0x02, 0x93, 0x6b, 0xfb, 0x9e, 0x32, 0x13, 0xf1, 0x10, 0x8a,
	0xf8, 0x3d, 0x6d, 0xdf, 0x4d, 0x65, 0x69, 0x67, 0xad, 0x7f, 0x17, 0x40, 0xd8, 0xc7, 0xa5, 0x71,
	0xcf, 0xcb, 0x90, 0x72, 0xf1, 0x52, 0x69, 0x0e, 0x97, 0xaf, 0x31, 0x57, 0x2c, 0xb1, 0x77, 0xd2,
	0x27, 0x9a, 0xbf, 0x5c, 0xc6, 0x23, 0x7d, 0x8a, 0x33, 0x64, 0xbb, 0x7c, 0xc1, 0x96, 0x78, 0x88,
	0x96, 0x90, 0x74, 0x4c, 0x6d, 0x2d, 0xf2, 0xfd, 0x09, 0xbf, 0xb0, 0x04, 0xdf, 0xb7, 0xfc, 0x3f,
	0x43, 0xd5, 0xfc, 0x31, 0x70, 0xb9, 0xe9, 0x2c, 0x72, 0x79, 0xfe, 0xfa, 0xc3, 0x6f, 0xf6, 0x19,
	0xb7, 0x6e, 0x9a, 0x31, 0xbd, 0xd1, 0x24, 0x24, 0xd9, 0x58, 0xec, 0x60, 0x11, 0x98, 0xe9, 0x43,
	0x6c, 0xb6, 0xfc, 0xc5, 0xdd, 0xff, 0x01, 0x30, 0xff, 0xcf, 0xfc, 0x94, 0xf8, 0x1e, 0xaa, 0xfc,
	0xec, 0x32, 0x56, 0x6d, 0x52, 0x7c, 0x74, 0x67, 0xd3, 0x20, 0x61, 0x30, 0x6d, 0x85, 0x9e, 0x03,
	0x9c, 0x5f, 0xc4, 0x13, 0xba, 0x29, 0xdc, 0x3f, 0xbf, 0xeb, 0xb2, 0xc9, 0xca, 0x79, 0x56, 0x14,
	0x9f, 0x9b, 0x3b, 0x60, 0xc9, 0xf0, 0x41, 0x72, 0x76, 0x07, 0x39, 0xf8, 0xcd, 0xb0, 0x75, 0x0a,
	0x30, 0x75, 0x0b, 0x3e, 0x27, 0x6a, 0x7b, 0x3b, 0xdd, 0xb3, 0x97, 0xb2, 0xe3, 0xf6, 0xba, 0x9d,
	0x3d, 0x7c, 0xc2, 0x62, 0x41, 0xa6, 0xc7, 0xac, 0x2b, 0x3b, 0x7b, 0xa7, 0x72, 0x1f, 0x9f, 0xb1,
	0x0d, 0x00, 0x7a, 0xc6, 0xda, 0x79, 0x8e, 0xe6, 0x68, 0x78, 0x32, 0xcf, 0xef, 0x7e, 0x0e, 0x0f,
	0xfa, 0xd1, 0x68, 0xf2, 0x79, 0xda, 0xe3, 0x88, 0x3f, 0xbf, 0xdb, 0x9c, 0x2e, 0x85, 0x0b, 0xbf,
	0xfe, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe1, 0x73, 0x1b, 0x9e, 0x01, 0x12, 0x00, 0x00,
}
